# Twenty-Forty-Eight
Created a console-based version of [Gabriele Cirulli's popular tiling game, 2048](https://gabrielecirulli.github.io/2048/).

<p align="center">
  <img src="https://github.com/RichlyElks/Twenty-Forty-Eight/blob/master/screenshot_2048.png">
</p>

 My final project for ECEN1310, Programming for Engineers, is implementing the popular online and mobile game 2048 with C. 2048 is played on a 4x4 board with tiles. The tiles start valued two or four, and the objective of the game is to create a 2048 tile by moving all of the tiles left, right, up or down so that when two tiles of the same value move in the same direction, they combine to form a single tile with their values doubled. To implement this game, I used many of the concepts introduced this semester including standard input/output, matrices, header and implementation files, and conditionals. This project succeeded because I approached it the same way as we were taught in class to build up a foundation of code. 

I began by deciding conceptually how I wanted the game to be structured. I would use a 4x4 matrix to hold the tiles’ values which would be manipulated through conditional statements based on the user’s inputs from stdin. First, reading characters from stdin was implemented followed by incorporating the matrix header and implementation files from homework 10. I adjusted the matrix library by removing any functions which would not be used and changed the stored data type from double to integer. The reason for the latter is that I wanted to use the bit-shift operator to increment the tiles when they combined and the game does not require any floating point numbers. 

I started with a 1x4 matrix: [2 0 0 0] and using the character input ‘l’ to move the two into the fourth column. A for loop would start in the fourth column and iterate to the left until it found a nonzero value. Another for loop, invoked from the previous conditional which is looking for a nonzero element, searches for the farthest consecutive empty element in which it would place the original element’s value in and then set the original element to zero. At this point, a matrix of [2 2 0 0] would correctly translate to [0 0 2 2]. The next feature to add was to have the element check its neighboring cell to see if they shared the same value, and if so, combine them into a single element with a single bit shift performed. The original implementation was easy, but a challenge quickly appeared when I realized that multiple cells were being unified despite only one “move”. For example, with the current implementation, [0 4 2 2] would turn into [0 0 0 8] in one turn when it should have only been [0 0 4 4]. After a few different attempts, the solution was reached by having a variable, called “changed”, originally set to zero, that if two elements were unified with each other, changed would be updated with its location, column in this example. Before unifying two cells, the “farthest” cell would have to be compared against the value of change to determine if it had already been unified in the current loop. If it was, no unification would occur but if it was not, then the unification would take place. At the end of the loop, changed would be reset to zero.

Translating the current logic of the game into the other directions and a 4x4 matrix was not too difficult. The biggest challenge was conceptually figuring out the conditions as they were not as simple as just swapping different values. 

The last part of the game’s logic to implement was spawning tiles randomly in empty elements of the matrix. This function required two consecutive for loops to iterate through the entire matrix and log any empty cells in two arrays, one for the row number and one for the column number, and stores the location of each empty cell and the number of empty cells to the cnt variable. Using rand() to get a random number, the remainder of the random number and the number of empty cells is found using the modulo and that gives us the cell which will be “spawned” or populated with either a 2 or 4 based on another modulo operation. There is a higher probability of 2’s being spawned. The spawned function is performed after every move by the player.

There were a few details omitted, such as keeping score, but the greatest challenges were in refining the conditionals to correctly emulate the original game. Print statements were useful in determining exactly where the dysfunction lied. Valgrind was also useful, especially in allowing the player to correctly exit the program. Originally, if a player pressed ‘q’, main() would return 0 and exit but after running the program through Valgrind, I realized I had not been deleting the matrices correctly and a deleteMatrix() amendment resolved the solution. I also altered the shell script from homework 10 to test the user’s input. 

Given more time, I would have liked to have used one of the curses libraries so the player would not have to press Enter after each move, and so there would be an actual “game board”. Curses/Ncurses would also allow for some color and design possibilities. I also did not have time to find a solution that would both determine when a player lost the game, all the tiles are filled without a possible move, and avoid the core dump that currently follows that situation. 

I really enjoyed the challenge that this project provided. It was a great opportunity to test the skills I’ve learned this semester. The project also exposed the areas that I need to work on, such as taking advantage of gdb and some using alternative data storage options. I have found a lot of satisfaction in where my current c programming skills have progressed over the semester, and this project was the perfect way to test them.
